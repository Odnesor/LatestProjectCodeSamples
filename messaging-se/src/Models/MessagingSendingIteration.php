<?php

namespace MessagingSmartEvaluering\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use MessagingSmartEvaluering\Loggers\IterationLogger;
use MessagingSmartEvaluering\Loggers\MessagingLoggerFactory;

/**
 * @property MessagingSendingFlow $flow
 * @property MessagingSender $sender
 * @property Collection $messages
 * @property MessagingScheduledSendingIteration $schedule
 * @property bool $is_finished
 * @property string $text
 */
class MessagingSendingIteration extends Model
{
    private $logger;

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);

        if ($connection = config('messaging-se.databaseconnection')) {
            $this->connection = $connection;
        }
    }

    protected $fillable = [
        'sender_id', 'text', 'is_finished'
    ];

    protected $casts = [
        'is_finished' => 'boolean'
    ];

    protected $appends = [
    ];

    public function flow(): BelongsToMany
    {
        return $this->belongsToMany(MessagingSendingFlow::class, 'messaging_sending_flows_schedules', 'iteration_id', 'flow_id')
            ->withPivot('scheduled_time', 'sent_at', 'order');
    }

    public function schedule(): BelongsToMany
    {
        return $this->belongsToMany(MessagingSendingFlow::class, 'messaging_sending_flows_schedules', 'iteration_id', 'flow_id')
            ->withPivot('scheduled_time', 'sent_at', 'order')->as('schedule')->using(MessagingScheduledSendingIteration::class);
    }

    public function getSchedule(): MessagingScheduledSendingIteration
    {
        return $this->schedule()->first()->schedule;
    }

    public function getFlow(): MessagingSendingFlow
    {
        return $this->flow()->first();
    }

    public function sender(): BelongsTo
    {
        return $this->belongsTo(MessagingSender::class, 'sender_id');
    }

    public function messages(): HasMany
    {
        return $this->hasMany(MessagingSendingIterationMessage::class, 'iteration_id');
    }

    /**
     * @return IterationLogger
     */
    public function getLogger(): IterationLogger
    {
        return $this->logger ?? ($this->logger = call_user_func(function () {
                $parentLogger = $this->getFlow()->getLogger();
                return MessagingLoggerFactory::getLogger(IterationLogger::class, $this)->setParentLogger($parentLogger);
            }));
    }

    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        static::creating(function (self $iteration) {
            if (!isset($iteration->sender) && isset($iteration->flow))
                $iteration->sender()->associate($iteration->flow->sender);
        });
    }
}