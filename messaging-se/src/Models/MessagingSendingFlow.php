<?php

namespace MessagingSmartEvaluering\Models;

use EmployeesSmartEvaluering\Filters\MessagingFlowFilterConjunction;
use EmployeesSmartEvaluering\Models\Employee;
use EmployeesSmartEvaluering\Models\MessagingFlowEmployeesFilter;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Collection;
use MessagingSmartEvaluering\Loggers\FlowLogger;
use MessagingSmartEvaluering\Loggers\IterationLogger;
use MessagingSmartEvaluering\Loggers\MessagingLoggerFactory;

/**
 * @property MessagingSender $sender
 * @property Collection $iterations
 * @property Collection $schedules
 * @property bool $is_active
 */
class MessagingSendingFlow extends Model
{
    private $logger;

    public function __construct(array $attributes = [])
    {
        parent::__construct($attributes);

        if ($connection = config('messaging-se.databaseconnection')) {
            $this->connection = $connection;
        }
    }

    protected $fillable = [
        'sender_id', 'name', 'description'
    ];

    protected $appends = [
        'startDate'
    ];

    protected $casts = [
        'startDate' => 'datetime:Y-m-d H:i:s',
        'is_active' => 'boolean'
    ];

    public function iterations(): BelongsToMany
    {
        return $this->belongsToMany(MessagingSendingIteration::class, 'messaging_sending_flows_schedules', 'flow_id', 'iteration_id')
            ->withPivot('scheduled_time', 'sent_at', 'order')->as('schedule');
    }

    public function getRawIterationsQuery()
    {
        $query = MessagingSendingIteration::whereIn('id', $this->iterations()->select('messaging_sending_iterations.id')->get()->pluck('id'));
        return $query;
    }

    public function sender(): BelongsTo
    {
        return $this->belongsTo(MessagingSender::class, 'sender_id');
    }

    public function schedules(): HasMany
    {
        return $this->hasMany(MessagingScheduledSendingIteration::class, 'flow_id')->orderBy('order')->with('iteration');
    }

    public function getStartDateAttribute()
    {
        return (($firstIteration = $this->schedules->first()) !== null ? $firstIteration->scheduled_time : null);
    }

    public function getLogger(): FlowLogger
    {
        return $this->logger ?? ($this->logger = call_user_func(function () {
                $parentLogger = $this->sender->getLogger();
                return MessagingLoggerFactory::getLogger(FlowLogger::class, $this)->setParentLogger($parentLogger);
            }));
    }

    public function toArray()
    {
        $data = parent::toArray();
        if (isset($data['startDate'])) $data['startDate'] = $data['startDate']->format('Y-m-d H:i:s');
        return $data; // TODO: Change the autogenerated stub
    }
}